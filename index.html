<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
    <link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
    <link rel='stylesheet' href='css/common.css'>

    <title>Posture Tracker AR</title>
  </head>
  <body>
    <div id="overlay">
      <header>
        <details open>
          <summary>Posture Tracker WebXR</summary>
          <p>
            This application tracks your head posture in AR and displays a warning when your posture is poor.
            <a class="back" href="./index.html">Back</a>
          </p>
          <div id="session-info"></div>
          <div id="pose"></div>
          <div id="warning-zone"></div>
          <button id="xr-button" class="barebones-button" disabled>XR not found</button>
        </details>
      </header>
    </div>
    <main style='text-align: center;'>
      <p>Click 'Enter AR' to start posture tracking</p>
    </main>
    <script type="module">
      // XR globals.
      let xrButton = document.getElementById('xr-button');
      let xrSession = null;
      let xrRefSpace = null;

      // WebGL scene globals.
      let gl = null;
      let program = null;

      function checkSupportedState() {
        navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
          if (supported) {
            xrButton.innerHTML = 'Enter AR';
          } else {
            xrButton.innerHTML = 'AR not found';
          }
          xrButton.disabled = !supported;
        });
      }

      function initXR() {
        if (!window.isSecureContext) {
          document.getElementById("warning-zone").innerText = "WebXR unavailable due to insecure context";
        }

        if (navigator.xr) {
          xrButton.addEventListener('click', onButtonClicked);
          navigator.xr.addEventListener('devicechange', checkSupportedState);
          checkSupportedState();
        }
      }

      function onButtonClicked() {
        if (!xrSession) {
          navigator.xr.requestSession('immersive-ar', {
            optionalFeatures: ['dom-overlay'],
            domOverlay: {root: document.getElementById('overlay')}
          }).then(onSessionStarted, onRequestSessionError);
        } else {
          xrSession.end();
        }
      }

      function onSessionStarted(session) {
        xrSession = session;
        xrButton.innerHTML = 'Exit AR';

        if (session.domOverlayState) {
          document.getElementById('session-info').innerHTML = 'DOM Overlay type: ' + session.domOverlayState.type;
        }

        session.addEventListener('end', onSessionEnded);
        let canvas = document.createElement('canvas');
        gl = canvas.getContext('webgl', { xrCompatible: true });
        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

        // Set up the WebGL program
        program = setupWebGLProgram(gl);

        session.requestReferenceSpace('local').then((refSpace) => {
          xrRefSpace = refSpace;
          session.requestAnimationFrame(onXRFrame);
        });
      }

      function setupWebGLProgram(gl) {
        const vsSource = `
          attribute vec4 aVertexPosition;
          uniform mat4 uModelViewMatrix;
          uniform mat4 uProjectionMatrix;
          void main() {
            gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
          }
        `;

        const fsSource = `
          precision mediump float;
          uniform vec4 uColor;
          void main() {
            gl_FragColor = uColor;
          }
        `;

        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
          return null;
        }

        return program;
      }

      function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }

        return shader;
      }

      function onRequestSessionError(ex) {
        alert("Failed to start immersive AR session.");
        console.error(ex.message);
      }

      function onSessionEnded(event) {
        xrSession = null;
        xrButton.innerHTML = 'Enter AR';
        document.getElementById('session-info').innerHTML = '';
        gl = null;
      }

      function drawWarningOverlay(gl, projectionMatrix, modelViewMatrix, color) {
        gl.useProgram(program);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [
          -1.0,  1.0,
           1.0,  1.0,
          -1.0, -1.0,
           1.0, -1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const vertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
        gl.vertexAttribPointer(vertexPosition, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(vertexPosition);

        const uModelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
        const uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');
        const uColor = gl.getUniformLocation(program, 'uColor');

        gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
        gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);
        gl.uniform4fv(uColor, color);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }

      function onXRFrame(t, frame) {
        let session = frame.session;
        session.requestAnimationFrame(onXRFrame);

        let pose = frame.getViewerPose(xrRefSpace);
        if (pose) {
          const p = pose.transform.position;
          document.getElementById('pose').innerText = "Position: " +
            p.x.toFixed(3) + ", " + p.y.toFixed(3) + ", " + p.z.toFixed(3);

          let isPoorPosture = p.y <= -0.000 && p.z >= 0.019;

          const glLayer = session.renderState.baseLayer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
          gl.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

          for (let view of pose.views) {
            const viewport = glLayer.getViewport(view);
            gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

            if (isPoorPosture) {
              // Calculate color based on time
              let time = Date.now();
              let r = (Math.cos(time / 2000) * 0.5 + 0.5) * 0.7;
              let g = (Math.cos(time / 4000) * 0.5 + 0.5) * 0.7;
              let b = (Math.cos(time / 6000) * 0.5 + 0.5) * 0.7;

              drawWarningOverlay(gl, view.projectionMatrix, view.transform.inverse.matrix, [r, g, b, 0.3]);
            }
          }
        } else {
          document.getElementById('pose').innerText = "Position: (null pose)";
        }
      }

      initXR();
    </script>
  </body>
</html>
